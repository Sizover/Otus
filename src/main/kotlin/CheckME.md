## Научиться работать с основными конструкциями языка и применять их на практике.
* Резюме:
Добрый день, хорошо что вы начали делать домашнее задание. Практика всегда полезна.
Пока что в предложенном вами варианте принять задание не представляется возможным, предлагаю доработать код.
Подсказски и рекомендации есть в этом PR - должно помочь.
Сдать еще раз на проверку исправленное задание.
Буду ждать новую версию, думаю все у вас получится, т.к. логика верная.




### Описание/Пошаговая инструкция выполнения домашнего задания:
Дан интерфейс interface TestRunner { fun  runTest(steps: T, test: () -> Unit) }. Класс, передаваемый в steps,
содержит методы before*/after*, которые задают предусловия/чистят данные перед/после теста.
Напишите свою реализацию интерфейса TestRunner, а именно:

1. Создайте класс реализующий интерфейс
2. Внутри класса переопределите метод runTest
3. Внутри этого метода необходимо сначала вызвать методы с before* из steps,
   далее прогнать тест (запустить передаваемую функцию test), и после вызвать методы с after* из steps.
4. Вызовы before* и after* нужно обернуть в лог/печать в консоль.
5. Проверьте работоспобоность написанного кода (можно в методе main).
   Код залейте на github. Название репозитория - otus-qa-kotlin-hw, ветка hw01-testrunner.
   В ДЗ отправьте ссылку на pull request.
   Вам потребуется 90-120 минут на выполнения задания.
   Если возникнут сложности, вы всегда можете обсудить их с одногруппниками или задать вопрос преподавателю Slack

### Критерии оценки:
### Критерии приемки:

1. При вызове метода runTest сначала вызываются методы before, далее идет прогон теста, после вызываются методы after
2. Начало и конец каждого шага (пред/постусловия, тест) логируется/выводится в консоль

В ветке Git нет buidgradle - не собирается, не запускается - добавлен
т.к. не было никаких библиотек - нет никаких импортов - код не стартуем
interface TestRunner - fun <T> RunTest желательно (и в задании) писать по норме Kotlin - fun runTest с малой буквы 
Generic T лучше поставьте в класс interface TestRunner<T> {, а из функции убрать: fun runTest(steps: T, test: () -> Unit)
Использользовать !! допустимо только в крайнем случае или для временной отладке - замените или уберите - не делайте так
Код использует java обращения(вместо kotlin-reflect) и неизветсно откуда их берет - наш курс на Kotlin
Если исправить библиотеки, то код работает
В котлине можно вместо экраниранирования "Логика метода \"some\"" внутри кавычек ставить одиночные кавычки "Логика метода 'some'"
Поставьте IntelliJ IDEA Community Edition https://www.jetbrains.com/ru-ru/idea/download/?section=windows 
Дайте File > New > Project from version Control  втяните из GitHub  эту ветку, раскомментируйте пример - запустите
Приведите свой код в соотвествие и запустите его
Отработайте все предложения и предупреждения  IntelliJ IDEA

Можно еще написать несколько классов типа Steps с разными конфигурациями after before и вызвать их через Ls1 из main
Можно попробовать вызвать с использованием DSL

Логика программы верная, однако синтаксис и правильное использование котлин и его библиотек почти отсутствует.

Иван Сизов21.06.2023 в 20:42
https://github.com/Sizover/Otus/tree/master
Но у меня затык с реализацией main
Ls1<T>().runTest(Steps(), { justFun() }) // все верно, но параметр Т для Ls1 надо дать конкретный иначе что он получит
что бы я не делал компилятор подчеркивает "Steps()" и никак мне не удалось его переубедить
(вот совсем не лучше было переносить дженерик с функции на интерфейс, если жденерик на функции или параметре интуитивно укладывается в понимании, то то что получилось у меня - вызывает массу вопросов)
Иван Сизов00:49
Вот так что ли должен выглядеть main?
Ls1<T>().runTest(Steps() as T, { justFun() })
Иван Сизов00:50
Ну потыкал и покрутил по всякому, так или иначе требования на мой взгляд реализованы, но изящество, на мой взгляд, в дефиците(
Ссылка прежняя
Иван Сизов00:54
чет под вечер стал по два раза повторять по два раза все))

22.06.2023
//Компилятор ругался на налбл защиту, но не принимал "?", и требовал только "!!"
Ответ: Вы путаете - красным Вам подчеркивает IntelliJ IDEA своим свойством LINT - он бывает ошибается - тогда JetBrains просит ему сообщать
компилятор всупает в работу после Build и/или Run - он последняя инстанция и сообщает обо всем в окошке Build.
// пришлось сделать налбл защиту через let 
Ответ: - можно по другому - изменить параметры - ведь Вы сами программист этого куска

В gradle-wrapper.properties надо поднять distributionUrl=https\://services.gradle.org/distributions/gradle-8.1.1-bin.zip
СМ вопрос выше: вызов из Main:
было Ls1().RunTest(Steps(), { justFun() }), а теперь Ls1<Steps>().runTest(Steps()) { justTestFun() } - работает

Резюме:
Внесите исправления по образцам в СВОЙ текст и убедитесь, что работает код, кроме того
Задание на тестирование before after =>
стоит создать еще тестовые классы:
class BeforeTwiceAndAfterTwiceTestClass {
class BeforeAndAfterTestClass {
class AfterOnlyTestClass {
class BeforeOnlyTestClass {
class EmptyTestClass

Можно вызвать их из mainчерез DSL:
ls1 {
runTest(BeforeOnlyTestClass()) { justTestFun() }
}
Должно работать и проверять на разных тестовых данных правильность тестируемого алгоритма
(сначала все before затем сам тест и потом все after) - тогда будет оттестировано

Рекомендации:
** Не экономьте на именах классов и функций - в команде будет недопонимание будет трудно работать в приличной команде:
** современный программист 30% времени, а тестер 50% времени придумывает имена, чтобы они были понятны команде  
** иначе придется обязательно писать комментарии (это тоже надо, но всем лень) 

Все хорошо осталось чуть-чуть до классного результата.
Жду третьею версии ДЗ №1.

Отличная работа - Принято.

Убирайте повторяющийся код
1. В Ls1 закомментируйте свой текст внизу и снимите комментарии вверху(CTRL /) - должно работать так же
2.  println("======== Передача в вызов 'BeforeTwiceAndAfterTwiceTestClass()' ================") можно перенести в Ls1
3. Пишите комментарии (см пример)
4. Опробуйте переименовать класс Ls1 и функцию ls1 (ПКМ на имени > refactor > rename) - должна везде поменять
5. правильно и логично распределяйте классы и функции по файлам и разносите файлы по пакетам
6. ,,,,,,,,,,
7. Добивайтесь совершенства

Жду второй работы ссылка на ToDo









